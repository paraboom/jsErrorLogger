{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///js_error_logger.min.js","webpack:///webpack/bootstrap c179dd33e689e6d86b85","webpack:///./src/index.coffee","webpack:///./~/stacktrace-js/stacktrace.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","JsErrorLogger","isObject","printStackTrace","slice","obj","type","options","errorProcessFn","window","onerror","onError","bind","prototype","message","url","line","symbol","e","hasExceptionObject","messageIsObject","notOurProblem","rethrow","_catch","data","processError","_errorData","catchWrap","fnOrObj","fnName","fn","origin","that","args","arguments","length","apply","error","catchWrapTimer","originFn","wrappedFn","eval","concat","_stacktrace","_stacktraceDump","JSON","stringify","_userAgent","navigator","userAgent","name","level","msg","stacktrace","global","guess","ex","mode","implementation","result","run","guessAnonymousFunctions","createException","other","callee","undef","indexOf","stack","sourceURL","number","fileName","split","instrumentFunction","context","functionName","callback","original","_instrumented","deinstrumentFunction","constructor","Function","chrome","replace","safari","ie","firefox","opera11","ANON","lineRE","lines","i","len","match","exec","location","push","opera10b","opera10a","opera9","phantomjs","curr","fnRE","maxStackSize","Array","test","toString","RegExp","$1","stringifyArguments","caller","arg","undefined","Object","String","Number","join","sourceCache","ajax","req","createXMLHTTPObject","open","send","responseText","xmlhttp","XMLHttpFactories","XMLHttpRequest","ActiveXObject","isSameDomain","hostname","getSource","reStack","reRef","frame","ref","file","lineno","charno","guessAnonymousFunction","lineNo","charNo","ret","findFunctionName","source","commentPos","reFunctionDeclaration","reFunctionExpression","reFunctionEvaluation","code","maxLines","Math","min","substr"],"mappings":"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","file":"js_error_logger.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AsyncFn\"] = factory();\n\telse\n\t\troot[\"AsyncFn\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AsyncFn\"] = factory();\n\telse\n\t\troot[\"AsyncFn\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar JsErrorLogger, isObject, printStackTrace,\n\t  slice = [].slice;\n\t\n\tprintStackTrace = __webpack_require__(2);\n\t\n\tisObject = function(obj) {\n\t  var type;\n\t  type = typeof obj;\n\t  return type === 'function' || type === 'object' && !!obj;\n\t};\n\t\n\tmodule.exports = JsErrorLogger = (function() {\n\t  function JsErrorLogger(options) {\n\t    this.errorProcessFn = options.errorProcessFn;\n\t    window.onerror = this.onError.bind(this);\n\t  }\n\t\n\t  JsErrorLogger.prototype.onError = function(message, url, line, symbol, e) {\n\t    var hasExceptionObject, messageIsObject, notOurProblem;\n\t    if (this.rethrow) {\n\t      this.rethrow = false;\n\t    } else {\n\t      notOurProblem = line === 0;\n\t      messageIsObject = isObject(message);\n\t      hasExceptionObject = e != null;\n\t      if (!notOurProblem) {\n\t        if (hasExceptionObject) {\n\t          this._catch(e);\n\t        } else if (messageIsObject) {\n\t          this._catch({\n\t            message: 'Unknown error',\n\t            data: message\n\t          });\n\t        } else {\n\t          this._catch({\n\t            message: \"Global error: \" + message + \" @ \" + url + \":\" + line + \":\" + symbol\n\t          });\n\t        }\n\t      }\n\t    }\n\t    return false;\n\t  };\n\t\n\t  JsErrorLogger.prototype.processError = function(e) {\n\t    return typeof this.errorProcessFn === \"function\" ? this.errorProcessFn(e, this._errorData(e)) : void 0;\n\t  };\n\t\n\t  JsErrorLogger.prototype.catchWrap = function(fnOrObj, fnName) {\n\t    var fn, obj, origin, that;\n\t    if (fnName) {\n\t      obj = fnOrObj;\n\t      origin = obj[fnName];\n\t      return obj[fnName] = this.catchWrap(origin);\n\t    } else {\n\t      fn = fnOrObj;\n\t      that = this;\n\t      return function() {\n\t        var args, e;\n\t        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t        try {\n\t          return fn.apply(this, args);\n\t        } catch (error) {\n\t          e = error;\n\t          throw e;\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  JsErrorLogger.prototype.catchWrapTimer = function(obj, fnName) {\n\t    var originFn, that;\n\t    originFn = obj[fnName];\n\t    that = this;\n\t    return obj[fnName] = function() {\n\t      var args, fn, wrappedFn;\n\t      fn = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n\t      wrappedFn = function() {\n\t        var e;\n\t        try {\n\t          if (typeof fn === 'string') {\n\t            return eval(fn);\n\t          } else {\n\t            return fn.apply(this, arguments);\n\t          }\n\t        } catch (error) {\n\t          e = error;\n\t          throw e;\n\t        }\n\t      };\n\t      return originFn.call.apply(originFn, [window, wrappedFn].concat(slice.call(args)));\n\t    };\n\t  };\n\t\n\t  JsErrorLogger.prototype._stacktrace = function(e) {\n\t    return printStackTrace({\n\t      e: e\n\t    });\n\t  };\n\t\n\t  JsErrorLogger.prototype._stacktraceDump = function(e) {\n\t    return JSON.stringify(this._stacktrace(e));\n\t  };\n\t\n\t  JsErrorLogger.prototype._userAgent = function() {\n\t    return navigator.userAgent;\n\t  };\n\t\n\t  JsErrorLogger.prototype._errorData = function(e) {\n\t    return {\n\t      name: e.name,\n\t      level: 'error',\n\t      msg: e.message,\n\t      data: e.data,\n\t      stacktrace: this._stacktraceDump(e)\n\t    };\n\t  };\n\t\n\t  JsErrorLogger.prototype._catch = function(e) {\n\t    return this.processError(e);\n\t  };\n\t\n\t  return JsErrorLogger;\n\n\t})();\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Domain Public by Eric Wendelin http://www.eriwen.com/ (2008)\n\t//                  Luke Smith http://lucassmith.name/ (2008)\n\t//                  Loic Dachary <loic@dachary.org> (2008)\n\t//                  Johan Euphrosine <proppy@aminche.com> (2008)\n\t//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)\n\t//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)\n\t/*global module, exports, define, ActiveXObject*/\n\t(function(global, factory) {\n\t    if (true) {\n\t        // Node\n\t        module.exports = factory();\n\t    } else if (typeof define === 'function' && define.amd) {\n\t        // AMD\n\t        define(factory);\n\t    } else {\n\t        // Browser globals\n\t        global.printStackTrace = factory();\n\t    }\n\t}(this, function() {\n\t    /**\n\t     * Main function giving a function stack trace with a forced or passed in Error\n\t     *\n\t     * @cfg {Error} e The error to create a stacktrace from (optional)\n\t     * @cfg {Boolean} guess If we should try to resolve the names of anonymous functions\n\t     * @return {Array} of Strings with functions, lines, files, and arguments where possible\n\t     */\n\t    function printStackTrace(options) {\n\t        options = options || {guess: true};\n\t        var ex = options.e || null, guess = !!options.guess, mode = options.mode || null;\n\t        var p = new printStackTrace.implementation(), result = p.run(ex, mode);\n\t        return (guess) ? p.guessAnonymousFunctions(result) : result;\n\t    }\n\t\n\t    printStackTrace.implementation = function() {\n\t    };\n\t\n\t    printStackTrace.implementation.prototype = {\n\t        /**\n\t         * @param {Error} [ex] The error to create a stacktrace from (optional)\n\t         * @param {String} [mode] Forced mode (optional, mostly for unit tests)\n\t         */\n\t        run: function(ex, mode) {\n\t            ex = ex || this.createException();\n\t            mode = mode || this.mode(ex);\n\t            if (mode === 'other') {\n\t                return this.other(arguments.callee);\n\t            } else {\n\t                return this[mode](ex);\n\t            }\n\t        },\n\t\n\t        createException: function() {\n\t            try {\n\t                this.undef();\n\t            } catch (e) {\n\t                return e;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Mode could differ for different exception, e.g.\n\t         * exceptions in Chrome may or may not have arguments or stack.\n\t         *\n\t         * @return {String} mode of operation for the exception\n\t         */\n\t        mode: function(e) {\n\t            if (typeof window !== 'undefined' && window.navigator.userAgent.indexOf('PhantomJS') > -1) {\n\t                return 'phantomjs';\n\t            }\n\t\n\t            if (e['arguments'] && e.stack) {\n\t                return 'chrome';\n\t            }\n\t\n\t            if (e.stack && e.sourceURL) {\n\t                return 'safari';\n\t            }\n\t\n\t            if (e.stack && e.number) {\n\t                return 'ie';\n\t            }\n\t\n\t            if (e.stack && e.fileName) {\n\t                return 'firefox';\n\t            }\n\t\n\t            if (e.message && e['opera#sourceloc']) {\n\t                // e.message.indexOf(\"Backtrace:\") > -1 -> opera9\n\t                // 'opera#sourceloc' in e -> opera9, opera10a\n\t                // !e.stacktrace -> opera9\n\t                if (!e.stacktrace) {\n\t                    return 'opera9'; // use e.message\n\t                }\n\t                if (e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n\t                    // e.message may have more stack entries than e.stacktrace\n\t                    return 'opera9'; // use e.message\n\t                }\n\t                return 'opera10a'; // use e.stacktrace\n\t            }\n\t\n\t            if (e.message && e.stack && e.stacktrace) {\n\t                // e.stacktrace && e.stack -> opera10b\n\t                if (e.stacktrace.indexOf(\"called from line\") < 0) {\n\t                    return 'opera10b'; // use e.stacktrace, format differs from 'opera10a'\n\t                }\n\t                // e.stacktrace && e.stack -> opera11\n\t                return 'opera11'; // use e.stacktrace, format differs from 'opera10a', 'opera10b'\n\t            }\n\t\n\t            if (e.stack && !e.fileName) {\n\t                // Chrome 27 does not have e.arguments as earlier versions,\n\t                // but still does not have e.fileName as Firefox\n\t                return 'chrome';\n\t            }\n\t\n\t            return 'other';\n\t        },\n\t\n\t        /**\n\t         * Given a context, function name, and callback function, overwrite it so that it calls\n\t         * printStackTrace() first with a callback and then runs the rest of the body.\n\t         *\n\t         * @param {Object} context of execution (e.g. window)\n\t         * @param {String} functionName to instrument\n\t         * @param {Function} callback function to call with a stack trace on invocation\n\t         */\n\t        instrumentFunction: function(context, functionName, callback) {\n\t            context = context || window;\n\t            var original = context[functionName];\n\t            context[functionName] = function instrumented() {\n\t                callback.call(this, printStackTrace().slice(4));\n\t                return context[functionName]._instrumented.apply(this, arguments);\n\t            };\n\t            context[functionName]._instrumented = original;\n\t        },\n\t\n\t        /**\n\t         * Given a context and function name of a function that has been\n\t         * instrumented, revert the function to it's original (non-instrumented)\n\t         * state.\n\t         *\n\t         * @param {Object} context of execution (e.g. window)\n\t         * @param {String} functionName to de-instrument\n\t         */\n\t        deinstrumentFunction: function(context, functionName) {\n\t            if (context[functionName].constructor === Function &&\n\t                context[functionName]._instrumented &&\n\t                context[functionName]._instrumented.constructor === Function) {\n\t                context[functionName] = context[functionName]._instrumented;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Given an Error object, return a formatted Array based on Chrome's stack string.\n\t         *\n\t         * @param e - Error object to inspect\n\t         * @return Array<String> of function calls, files and line numbers\n\t         */\n\t        chrome: function(e) {\n\t            return (e.stack + '\\n')\n\t                .replace(/^[\\s\\S]+?\\s+at\\s+/, ' at ') // remove message\n\t                .replace(/^\\s+(at eval )?at\\s+/gm, '') // remove 'at' and indentation\n\t                .replace(/^([^\\(]+?)([\\n$])/gm, '{anonymous}() ($1)$2')\n\t                .replace(/^Object.<anonymous>\\s*\\(([^\\)]+)\\)/gm, '{anonymous}() ($1)')\n\t                .replace(/^(.+) \\((.+)\\)$/gm, '$1@$2')\n\t                .split('\\n')\n\t                .slice(0, -1);\n\t        },\n\t\n\t        /**\n\t         * Given an Error object, return a formatted Array based on Safari's stack string.\n\t         *\n\t         * @param e - Error object to inspect\n\t         * @return Array<String> of function calls, files and line numbers\n\t         */\n\t        safari: function(e) {\n\t            return e.stack.replace(/\\[native code\\]\\n/m, '')\n\t                .replace(/^(?=\\w+Error\\:).*$\\n/m, '')\n\t                .replace(/^@/gm, '{anonymous}()@')\n\t                .split('\\n');\n\t        },\n\t\n\t        /**\n\t         * Given an Error object, return a formatted Array based on IE's stack string.\n\t         *\n\t         * @param e - Error object to inspect\n\t         * @return Array<String> of function calls, files and line numbers\n\t         */\n\t        ie: function(e) {\n\t            return e.stack\n\t                .replace(/^\\s*at\\s+(.*)$/gm, '$1')\n\t                .replace(/^Anonymous function\\s+/gm, '{anonymous}() ')\n\t                .replace(/^(.+)\\s+\\((.+)\\)$/gm, '$1@$2')\n\t                .split('\\n')\n\t                .slice(1);\n\t        },\n\t\n\t        /**\n\t         * Given an Error object, return a formatted Array based on Firefox's stack string.\n\t         *\n\t         * @param e - Error object to inspect\n\t         * @return Array<String> of function calls, files and line numbers\n\t         */\n\t        firefox: function(e) {\n\t            return e.stack.replace(/(?:\\n@:0)?\\s+$/m, '')\n\t                .replace(/^(?:\\((\\S*)\\))?@/gm, '{anonymous}($1)@')\n\t                .split('\\n');\n\t        },\n\t\n\t        opera11: function(e) {\n\t            var ANON = '{anonymous}', lineRE = /^.*line (\\d+), column (\\d+)(?: in (.+))? in (\\S+):$/;\n\t            var lines = e.stacktrace.split('\\n'), result = [];\n\t\n\t            for (var i = 0, len = lines.length; i < len; i += 2) {\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    var location = match[4] + ':' + match[1] + ':' + match[2];\n\t                    var fnName = match[3] || \"global code\";\n\t                    fnName = fnName.replace(/<anonymous function: (\\S+)>/, \"$1\").replace(/<anonymous function>/, ANON);\n\t                    result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        opera10b: function(e) {\n\t            // \"<anonymous function: run>([arguments not available])@file://localhost/G:/js/stacktrace.js:27\\n\" +\n\t            // \"printStackTrace([arguments not available])@file://localhost/G:/js/stacktrace.js:18\\n\" +\n\t            // \"@file://localhost/G:/js/test/functional/testcase1.html:15\"\n\t            var lineRE = /^(.*)@(.+):(\\d+)$/;\n\t            var lines = e.stacktrace.split('\\n'), result = [];\n\t\n\t            for (var i = 0, len = lines.length; i < len; i++) {\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    var fnName = match[1] ? (match[1] + '()') : \"global code\";\n\t                    result.push(fnName + '@' + match[2] + ':' + match[3]);\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        /**\n\t         * Given an Error object, return a formatted Array based on Opera 10's stacktrace string.\n\t         *\n\t         * @param e - Error object to inspect\n\t         * @return Array<String> of function calls, files and line numbers\n\t         */\n\t        opera10a: function(e) {\n\t            // \"  Line 27 of linked script file://localhost/G:/js/stacktrace.js\\n\"\n\t            // \"  Line 11 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html: In function foo\\n\"\n\t            var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n\t            var lines = e.stacktrace.split('\\n'), result = [];\n\t\n\t            for (var i = 0, len = lines.length; i < len; i += 2) {\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    var fnName = match[3] || ANON;\n\t                    result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        // Opera 7.x-9.2x only!\n\t        opera9: function(e) {\n\t            // \"  Line 43 of linked script file://localhost/G:/js/stacktrace.js\\n\"\n\t            // \"  Line 7 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html\\n\"\n\t            var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n\t            var lines = e.message.split('\\n'), result = [];\n\t\n\t            for (var i = 2, len = lines.length; i < len; i += 2) {\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        phantomjs: function(e) {\n\t            var ANON = '{anonymous}', lineRE = /(\\S+) \\((\\S+)\\)/i;\n\t            var lines = e.stack.split('\\n'), result = [];\n\t\n\t            for (var i = 1, len = lines.length; i < len; i++) {\n\t                lines[i] = lines[i].replace(/^\\s+at\\s+/gm, '');\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    result.push(match[1] + '()@' + match[2]);\n\t                }\n\t                else {\n\t                    result.push(ANON + '()@' + lines[i]);\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        // Safari 5-, IE 9-, and others\n\t        other: function(curr) {\n\t            var ANON = '{anonymous}', fnRE = /function(?:\\s+([\\w$]+))?\\s*\\(/, stack = [], fn, args, maxStackSize = 10;\n\t            var slice = Array.prototype.slice;\n\t            while (curr && stack.length < maxStackSize) {\n\t                fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;\n\t                try {\n\t                    args = slice.call(curr['arguments'] || []);\n\t                } catch (e) {\n\t                    args = ['Cannot access arguments: ' + e];\n\t                }\n\t                stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';\n\t                try {\n\t                    curr = curr.caller;\n\t                } catch (e) {\n\t                    stack[stack.length] = 'Cannot access caller: ' + e;\n\t                    break;\n\t                }\n\t            }\n\t            return stack;\n\t        },\n\t\n\t        /**\n\t         * Given arguments array as a String, substituting type names for non-string types.\n\t         *\n\t         * @param {Arguments,Array} args\n\t         * @return {String} stringified arguments\n\t         */\n\t        stringifyArguments: function(args) {\n\t            var result = [];\n\t            var slice = Array.prototype.slice;\n\t            for (var i = 0; i < args.length; ++i) {\n\t                var arg = args[i];\n\t                if (arg === undefined) {\n\t                    result[i] = 'undefined';\n\t                } else if (arg === null) {\n\t                    result[i] = 'null';\n\t                } else if (arg.constructor) {\n\t                    // TODO constructor comparison does not work for iframes\n\t                    if (arg.constructor === Array) {\n\t                        if (arg.length < 3) {\n\t                            result[i] = '[' + this.stringifyArguments(arg) + ']';\n\t                        } else {\n\t                            result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';\n\t                        }\n\t                    } else if (arg.constructor === Object) {\n\t                        result[i] = '#object';\n\t                    } else if (arg.constructor === Function) {\n\t                        result[i] = '#function';\n\t                    } else if (arg.constructor === String) {\n\t                        result[i] = '\"' + arg + '\"';\n\t                    } else if (arg.constructor === Number) {\n\t                        result[i] = arg;\n\t                    } else {\n\t                        result[i] = '?';\n\t                    }\n\t                }\n\t            }\n\t            return result.join(',');\n\t        },\n\t\n\t        sourceCache: {},\n\t\n\t        /**\n\t         * @return {String} the text from a given URL\n\t         */\n\t        ajax: function(url) {\n\t            var req = this.createXMLHTTPObject();\n\t            if (req) {\n\t                try {\n\t                    req.open('GET', url, false);\n\t                    //req.overrideMimeType('text/plain');\n\t                    //req.overrideMimeType('text/javascript');\n\t                    req.send(null);\n\t                    //return req.status == 200 ? req.responseText : '';\n\t                    return req.responseText;\n\t                } catch (e) {\n\t                }\n\t            }\n\t            return '';\n\t        },\n\t\n\t        /**\n\t         * Try XHR methods in order and store XHR factory.\n\t         *\n\t         * @return {XMLHttpRequest} XHR function or equivalent\n\t         */\n\t        createXMLHTTPObject: function() {\n\t            var xmlhttp, XMLHttpFactories = [\n\t                function() {\n\t                    return new XMLHttpRequest();\n\t                }, function() {\n\t                    return new ActiveXObject('Msxml2.XMLHTTP');\n\t                }, function() {\n\t                    return new ActiveXObject('Msxml3.XMLHTTP');\n\t                }, function() {\n\t                    return new ActiveXObject('Microsoft.XMLHTTP');\n\t                }\n\t            ];\n\t            for (var i = 0; i < XMLHttpFactories.length; i++) {\n\t                try {\n\t                    xmlhttp = XMLHttpFactories[i]();\n\t                    // Use memoization to cache the factory\n\t                    this.createXMLHTTPObject = XMLHttpFactories[i];\n\t                    return xmlhttp;\n\t                } catch (e) {\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Given a URL, check if it is in the same domain (so we can get the source\n\t         * via Ajax).\n\t         *\n\t         * @param url {String} source url\n\t         * @return {Boolean} False if we need a cross-domain request\n\t         */\n\t        isSameDomain: function(url) {\n\t            return typeof location !== \"undefined\" && url.indexOf(location.hostname) !== -1; // location may not be defined, e.g. when running from nodejs.\n\t        },\n\t\n\t        /**\n\t         * Get source code from given URL if in the same domain.\n\t         *\n\t         * @param url {String} JS source URL\n\t         * @return {Array} Array of source code lines\n\t         */\n\t        getSource: function(url) {\n\t            // TODO reuse source from script tags?\n\t            if (!(url in this.sourceCache)) {\n\t                this.sourceCache[url] = this.ajax(url).split('\\n');\n\t            }\n\t            return this.sourceCache[url];\n\t        },\n\t\n\t        guessAnonymousFunctions: function(stack) {\n\t            for (var i = 0; i < stack.length; ++i) {\n\t                var reStack = /\\{anonymous\\}\\(.*\\)@(.*)/,\n\t                    reRef = /^(.*?)(?::(\\d+))(?::(\\d+))?(?: -- .+)?$/,\n\t                    frame = stack[i], ref = reStack.exec(frame);\n\t\n\t                if (ref) {\n\t                    var m = reRef.exec(ref[1]);\n\t                    if (m) { // If falsey, we did not get any file/line information\n\t                        var file = m[1], lineno = m[2], charno = m[3] || 0;\n\t                        if (file && this.isSameDomain(file) && lineno) {\n\t                            var functionName = this.guessAnonymousFunction(file, lineno, charno);\n\t                            stack[i] = frame.replace('{anonymous}', functionName);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            return stack;\n\t        },\n\t\n\t        guessAnonymousFunction: function(url, lineNo, charNo) {\n\t            var ret;\n\t            try {\n\t                ret = this.findFunctionName(this.getSource(url), lineNo);\n\t            } catch (e) {\n\t                ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();\n\t            }\n\t            return ret;\n\t        },\n\t\n\t        findFunctionName: function(source, lineNo) {\n\t            // FIXME findFunctionName fails for compressed source\n\t            // (more than one function on the same line)\n\t            // function {name}({args}) m[1]=name m[2]=args\n\t            var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\n\t            // {name} = function ({args}) TODO args capture\n\t            // /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*function(?:[^(]*)/\n\t            var reFunctionExpression = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/;\n\t            // {name} = eval()\n\t            var reFunctionEvaluation = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\n\t            // Walk backwards in the source lines until we find\n\t            // the line which matches one of the patterns above\n\t            var code = \"\", line, maxLines = Math.min(lineNo, 20), m, commentPos;\n\t            for (var i = 0; i < maxLines; ++i) {\n\t                // lineNo is 1-based, source[] is 0-based\n\t                line = source[lineNo - i - 1];\n\t                commentPos = line.indexOf('//');\n\t                if (commentPos >= 0) {\n\t                    line = line.substr(0, commentPos);\n\t                }\n\t                // TODO check other types of comments? Commented code may lead to false positive\n\t                if (line) {\n\t                    code = line + code;\n\t                    m = reFunctionExpression.exec(code);\n\t                    if (m && m[1]) {\n\t                        return m[1];\n\t                    }\n\t                    m = reFunctionDeclaration.exec(code);\n\t                    if (m && m[1]) {\n\t                        //return m[1] + \"(\" + (m[2] || \"\") + \")\";\n\t                        return m[1];\n\t                    }\n\t                    m = reFunctionEvaluation.exec(code);\n\t                    if (m && m[1]) {\n\t                        return m[1];\n\t                    }\n\t                }\n\t            }\n\t            return '(?)';\n\t        }\n\t    };\n\t\n\t    return printStackTrace;\n\t}));\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// js_error_logger.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c179dd33e689e6d86b85","printStackTrace = require 'stacktrace-js'\n\nisObject = (obj) ->\n  type = typeof obj\n  type is 'function' or type is 'object' and !!obj\n\nmodule.exports = class JsErrorLogger\n  constructor: (options) ->\n    {@errorProcessFn} = options\n    window.onerror = @onError.bind(@)\n\n  # Proccess global exceptions.\n  #\n  # Examples\n  #\n  #   window.onerror = Core.onError\n  #\n  # Always returns false to prevent default error proccessing.\n  onError: (message, url, line, symbol, e) ->\n    if @rethrow\n      @rethrow = false\n    else\n      # Exceptions at line 0 basically are errors in scripts violates a\n      # browser's cross-origin policy.\n      #\n      # More info: http://blog.errorception.com/2012/04/script-error-on-line-0.html.\n      #\n      # Some exceptions at line 0 are NPObject errors, them also should be\n      # ignored because they are throwed in a browser's plugin (e.g Flash).\n      #\n      # > NPObject is an \"interface\" to any \"foreign\" code exposed through\n      # > the browser\n      #\n      # More info: http://stackoverflow.com/a/8938931/75284\n      notOurProblem = line is 0\n      messageIsObject = isObject(message)\n      hasExceptionObject = e?\n\n      unless notOurProblem\n        if hasExceptionObject\n          @_catch(e)\n        else if messageIsObject\n          @_catch(message: 'Unknown error', data: message)\n        else\n          @_catch(message: \"Global error: #{message} @ #{url}:#{line}:#{symbol}\")\n\n    false\n\n  processError: (e) ->\n    @errorProcessFn?(e, @_errorData(e))\n\n  # Wrap function into try-catch.\n  catchWrap: (fnOrObj, fnName) ->\n    if fnName\n      obj = fnOrObj\n      origin = obj[fnName]\n      obj[fnName] = @catchWrap(origin)\n\n    else\n      fn = fnOrObj\n      that = @\n\n      (args...) ->\n        try\n          fn.apply(@, args)\n        catch e\n          throw e\n\n  catchWrapTimer: (obj, fnName) ->\n    originFn = obj[fnName]\n    that = @\n    obj[fnName] = (fn, args...) ->\n\n      wrappedFn = ->\n        try\n          if typeof fn is 'string'\n            eval(fn)\n          else\n            fn.apply(@, arguments)\n        catch e\n          throw e\n\n      originFn.call(window, wrappedFn, args...)\n\n  ## Private\n\n  # Returns call stack.\n  #\n  # Examples\n  #\n  #   Core.stacktrace()\n  #   # => [\n  #   #      ...\n  #   #      \"_.extend.delegateEvents (http://toptal.dev/assets/backbone.js?body=1:1339:24)\",\n  #   #      \"Framework.View.View.delegateEvents (http://toptal.dev/assets/framework/base/view.js?body=1:81:44)\",\n  #   #      \"Backbone.View (http://toptal.dev/assets/backbone.js?body=1:1261:10)\",\n  #   #      \"View (http://toptal.dev/assets/framework/base/view.js?body=1:12:34)\",\n  #   #      ...\n  #   #    ]\n  #\n  # Returns array.\n  _stacktrace: (e) ->\n    printStackTrace {e}\n\n  # Returns stringified stacktrace.\n  _stacktraceDump: (e) ->\n    JSON.stringify(@_stacktrace(e))\n\n  # Returns user agent\n  _userAgent: ->\n    navigator.userAgent\n\n  # Returns exception data\n  _errorData: (e) ->\n    name: e.name\n    level: 'error'\n    msg: e.message\n    data: e.data\n    stacktrace: @_stacktraceDump(e)\n\n  # Process JS exception.\n  _catch: (e) ->\n    @processError(e)\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.coffee","// Domain Public by Eric Wendelin http://www.eriwen.com/ (2008)\n//                  Luke Smith http://lucassmith.name/ (2008)\n//                  Loic Dachary <loic@dachary.org> (2008)\n//                  Johan Euphrosine <proppy@aminche.com> (2008)\n//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)\n//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)\n/*global module, exports, define, ActiveXObject*/\n(function(global, factory) {\n    if (typeof exports === 'object') {\n        // Node\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals\n        global.printStackTrace = factory();\n    }\n}(this, function() {\n    /**\n     * Main function giving a function stack trace with a forced or passed in Error\n     *\n     * @cfg {Error} e The error to create a stacktrace from (optional)\n     * @cfg {Boolean} guess If we should try to resolve the names of anonymous functions\n     * @return {Array} of Strings with functions, lines, files, and arguments where possible\n     */\n    function printStackTrace(options) {\n        options = options || {guess: true};\n        var ex = options.e || null, guess = !!options.guess, mode = options.mode || null;\n        var p = new printStackTrace.implementation(), result = p.run(ex, mode);\n        return (guess) ? p.guessAnonymousFunctions(result) : result;\n    }\n\n    printStackTrace.implementation = function() {\n    };\n\n    printStackTrace.implementation.prototype = {\n        /**\n         * @param {Error} [ex] The error to create a stacktrace from (optional)\n         * @param {String} [mode] Forced mode (optional, mostly for unit tests)\n         */\n        run: function(ex, mode) {\n            ex = ex || this.createException();\n            mode = mode || this.mode(ex);\n            if (mode === 'other') {\n                return this.other(arguments.callee);\n            } else {\n                return this[mode](ex);\n            }\n        },\n\n        createException: function() {\n            try {\n                this.undef();\n            } catch (e) {\n                return e;\n            }\n        },\n\n        /**\n         * Mode could differ for different exception, e.g.\n         * exceptions in Chrome may or may not have arguments or stack.\n         *\n         * @return {String} mode of operation for the exception\n         */\n        mode: function(e) {\n            if (typeof window !== 'undefined' && window.navigator.userAgent.indexOf('PhantomJS') > -1) {\n                return 'phantomjs';\n            }\n\n            if (e['arguments'] && e.stack) {\n                return 'chrome';\n            }\n\n            if (e.stack && e.sourceURL) {\n                return 'safari';\n            }\n\n            if (e.stack && e.number) {\n                return 'ie';\n            }\n\n            if (e.stack && e.fileName) {\n                return 'firefox';\n            }\n\n            if (e.message && e['opera#sourceloc']) {\n                // e.message.indexOf(\"Backtrace:\") > -1 -> opera9\n                // 'opera#sourceloc' in e -> opera9, opera10a\n                // !e.stacktrace -> opera9\n                if (!e.stacktrace) {\n                    return 'opera9'; // use e.message\n                }\n                if (e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n                    // e.message may have more stack entries than e.stacktrace\n                    return 'opera9'; // use e.message\n                }\n                return 'opera10a'; // use e.stacktrace\n            }\n\n            if (e.message && e.stack && e.stacktrace) {\n                // e.stacktrace && e.stack -> opera10b\n                if (e.stacktrace.indexOf(\"called from line\") < 0) {\n                    return 'opera10b'; // use e.stacktrace, format differs from 'opera10a'\n                }\n                // e.stacktrace && e.stack -> opera11\n                return 'opera11'; // use e.stacktrace, format differs from 'opera10a', 'opera10b'\n            }\n\n            if (e.stack && !e.fileName) {\n                // Chrome 27 does not have e.arguments as earlier versions,\n                // but still does not have e.fileName as Firefox\n                return 'chrome';\n            }\n\n            return 'other';\n        },\n\n        /**\n         * Given a context, function name, and callback function, overwrite it so that it calls\n         * printStackTrace() first with a callback and then runs the rest of the body.\n         *\n         * @param {Object} context of execution (e.g. window)\n         * @param {String} functionName to instrument\n         * @param {Function} callback function to call with a stack trace on invocation\n         */\n        instrumentFunction: function(context, functionName, callback) {\n            context = context || window;\n            var original = context[functionName];\n            context[functionName] = function instrumented() {\n                callback.call(this, printStackTrace().slice(4));\n                return context[functionName]._instrumented.apply(this, arguments);\n            };\n            context[functionName]._instrumented = original;\n        },\n\n        /**\n         * Given a context and function name of a function that has been\n         * instrumented, revert the function to it's original (non-instrumented)\n         * state.\n         *\n         * @param {Object} context of execution (e.g. window)\n         * @param {String} functionName to de-instrument\n         */\n        deinstrumentFunction: function(context, functionName) {\n            if (context[functionName].constructor === Function &&\n                context[functionName]._instrumented &&\n                context[functionName]._instrumented.constructor === Function) {\n                context[functionName] = context[functionName]._instrumented;\n            }\n        },\n\n        /**\n         * Given an Error object, return a formatted Array based on Chrome's stack string.\n         *\n         * @param e - Error object to inspect\n         * @return Array<String> of function calls, files and line numbers\n         */\n        chrome: function(e) {\n            return (e.stack + '\\n')\n                .replace(/^[\\s\\S]+?\\s+at\\s+/, ' at ') // remove message\n                .replace(/^\\s+(at eval )?at\\s+/gm, '') // remove 'at' and indentation\n                .replace(/^([^\\(]+?)([\\n$])/gm, '{anonymous}() ($1)$2')\n                .replace(/^Object.<anonymous>\\s*\\(([^\\)]+)\\)/gm, '{anonymous}() ($1)')\n                .replace(/^(.+) \\((.+)\\)$/gm, '$1@$2')\n                .split('\\n')\n                .slice(0, -1);\n        },\n\n        /**\n         * Given an Error object, return a formatted Array based on Safari's stack string.\n         *\n         * @param e - Error object to inspect\n         * @return Array<String> of function calls, files and line numbers\n         */\n        safari: function(e) {\n            return e.stack.replace(/\\[native code\\]\\n/m, '')\n                .replace(/^(?=\\w+Error\\:).*$\\n/m, '')\n                .replace(/^@/gm, '{anonymous}()@')\n                .split('\\n');\n        },\n\n        /**\n         * Given an Error object, return a formatted Array based on IE's stack string.\n         *\n         * @param e - Error object to inspect\n         * @return Array<String> of function calls, files and line numbers\n         */\n        ie: function(e) {\n            return e.stack\n                .replace(/^\\s*at\\s+(.*)$/gm, '$1')\n                .replace(/^Anonymous function\\s+/gm, '{anonymous}() ')\n                .replace(/^(.+)\\s+\\((.+)\\)$/gm, '$1@$2')\n                .split('\\n')\n                .slice(1);\n        },\n\n        /**\n         * Given an Error object, return a formatted Array based on Firefox's stack string.\n         *\n         * @param e - Error object to inspect\n         * @return Array<String> of function calls, files and line numbers\n         */\n        firefox: function(e) {\n            return e.stack.replace(/(?:\\n@:0)?\\s+$/m, '')\n                .replace(/^(?:\\((\\S*)\\))?@/gm, '{anonymous}($1)@')\n                .split('\\n');\n        },\n\n        opera11: function(e) {\n            var ANON = '{anonymous}', lineRE = /^.*line (\\d+), column (\\d+)(?: in (.+))? in (\\S+):$/;\n            var lines = e.stacktrace.split('\\n'), result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    var location = match[4] + ':' + match[1] + ':' + match[2];\n                    var fnName = match[3] || \"global code\";\n                    fnName = fnName.replace(/<anonymous function: (\\S+)>/, \"$1\").replace(/<anonymous function>/, ANON);\n                    result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n                }\n            }\n\n            return result;\n        },\n\n        opera10b: function(e) {\n            // \"<anonymous function: run>([arguments not available])@file://localhost/G:/js/stacktrace.js:27\\n\" +\n            // \"printStackTrace([arguments not available])@file://localhost/G:/js/stacktrace.js:18\\n\" +\n            // \"@file://localhost/G:/js/test/functional/testcase1.html:15\"\n            var lineRE = /^(.*)@(.+):(\\d+)$/;\n            var lines = e.stacktrace.split('\\n'), result = [];\n\n            for (var i = 0, len = lines.length; i < len; i++) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    var fnName = match[1] ? (match[1] + '()') : \"global code\";\n                    result.push(fnName + '@' + match[2] + ':' + match[3]);\n                }\n            }\n\n            return result;\n        },\n\n        /**\n         * Given an Error object, return a formatted Array based on Opera 10's stacktrace string.\n         *\n         * @param e - Error object to inspect\n         * @return Array<String> of function calls, files and line numbers\n         */\n        opera10a: function(e) {\n            // \"  Line 27 of linked script file://localhost/G:/js/stacktrace.js\\n\"\n            // \"  Line 11 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html: In function foo\\n\"\n            var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split('\\n'), result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    var fnName = match[3] || ANON;\n                    result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n                }\n            }\n\n            return result;\n        },\n\n        // Opera 7.x-9.2x only!\n        opera9: function(e) {\n            // \"  Line 43 of linked script file://localhost/G:/js/stacktrace.js\\n\"\n            // \"  Line 7 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html\\n\"\n            var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split('\\n'), result = [];\n\n            for (var i = 2, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n                }\n            }\n\n            return result;\n        },\n\n        phantomjs: function(e) {\n            var ANON = '{anonymous}', lineRE = /(\\S+) \\((\\S+)\\)/i;\n            var lines = e.stack.split('\\n'), result = [];\n\n            for (var i = 1, len = lines.length; i < len; i++) {\n                lines[i] = lines[i].replace(/^\\s+at\\s+/gm, '');\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(match[1] + '()@' + match[2]);\n                }\n                else {\n                    result.push(ANON + '()@' + lines[i]);\n                }\n            }\n\n            return result;\n        },\n\n        // Safari 5-, IE 9-, and others\n        other: function(curr) {\n            var ANON = '{anonymous}', fnRE = /function(?:\\s+([\\w$]+))?\\s*\\(/, stack = [], fn, args, maxStackSize = 10;\n            var slice = Array.prototype.slice;\n            while (curr && stack.length < maxStackSize) {\n                fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;\n                try {\n                    args = slice.call(curr['arguments'] || []);\n                } catch (e) {\n                    args = ['Cannot access arguments: ' + e];\n                }\n                stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';\n                try {\n                    curr = curr.caller;\n                } catch (e) {\n                    stack[stack.length] = 'Cannot access caller: ' + e;\n                    break;\n                }\n            }\n            return stack;\n        },\n\n        /**\n         * Given arguments array as a String, substituting type names for non-string types.\n         *\n         * @param {Arguments,Array} args\n         * @return {String} stringified arguments\n         */\n        stringifyArguments: function(args) {\n            var result = [];\n            var slice = Array.prototype.slice;\n            for (var i = 0; i < args.length; ++i) {\n                var arg = args[i];\n                if (arg === undefined) {\n                    result[i] = 'undefined';\n                } else if (arg === null) {\n                    result[i] = 'null';\n                } else if (arg.constructor) {\n                    // TODO constructor comparison does not work for iframes\n                    if (arg.constructor === Array) {\n                        if (arg.length < 3) {\n                            result[i] = '[' + this.stringifyArguments(arg) + ']';\n                        } else {\n                            result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';\n                        }\n                    } else if (arg.constructor === Object) {\n                        result[i] = '#object';\n                    } else if (arg.constructor === Function) {\n                        result[i] = '#function';\n                    } else if (arg.constructor === String) {\n                        result[i] = '\"' + arg + '\"';\n                    } else if (arg.constructor === Number) {\n                        result[i] = arg;\n                    } else {\n                        result[i] = '?';\n                    }\n                }\n            }\n            return result.join(',');\n        },\n\n        sourceCache: {},\n\n        /**\n         * @return {String} the text from a given URL\n         */\n        ajax: function(url) {\n            var req = this.createXMLHTTPObject();\n            if (req) {\n                try {\n                    req.open('GET', url, false);\n                    //req.overrideMimeType('text/plain');\n                    //req.overrideMimeType('text/javascript');\n                    req.send(null);\n                    //return req.status == 200 ? req.responseText : '';\n                    return req.responseText;\n                } catch (e) {\n                }\n            }\n            return '';\n        },\n\n        /**\n         * Try XHR methods in order and store XHR factory.\n         *\n         * @return {XMLHttpRequest} XHR function or equivalent\n         */\n        createXMLHTTPObject: function() {\n            var xmlhttp, XMLHttpFactories = [\n                function() {\n                    return new XMLHttpRequest();\n                }, function() {\n                    return new ActiveXObject('Msxml2.XMLHTTP');\n                }, function() {\n                    return new ActiveXObject('Msxml3.XMLHTTP');\n                }, function() {\n                    return new ActiveXObject('Microsoft.XMLHTTP');\n                }\n            ];\n            for (var i = 0; i < XMLHttpFactories.length; i++) {\n                try {\n                    xmlhttp = XMLHttpFactories[i]();\n                    // Use memoization to cache the factory\n                    this.createXMLHTTPObject = XMLHttpFactories[i];\n                    return xmlhttp;\n                } catch (e) {\n                }\n            }\n        },\n\n        /**\n         * Given a URL, check if it is in the same domain (so we can get the source\n         * via Ajax).\n         *\n         * @param url {String} source url\n         * @return {Boolean} False if we need a cross-domain request\n         */\n        isSameDomain: function(url) {\n            return typeof location !== \"undefined\" && url.indexOf(location.hostname) !== -1; // location may not be defined, e.g. when running from nodejs.\n        },\n\n        /**\n         * Get source code from given URL if in the same domain.\n         *\n         * @param url {String} JS source URL\n         * @return {Array} Array of source code lines\n         */\n        getSource: function(url) {\n            // TODO reuse source from script tags?\n            if (!(url in this.sourceCache)) {\n                this.sourceCache[url] = this.ajax(url).split('\\n');\n            }\n            return this.sourceCache[url];\n        },\n\n        guessAnonymousFunctions: function(stack) {\n            for (var i = 0; i < stack.length; ++i) {\n                var reStack = /\\{anonymous\\}\\(.*\\)@(.*)/,\n                    reRef = /^(.*?)(?::(\\d+))(?::(\\d+))?(?: -- .+)?$/,\n                    frame = stack[i], ref = reStack.exec(frame);\n\n                if (ref) {\n                    var m = reRef.exec(ref[1]);\n                    if (m) { // If falsey, we did not get any file/line information\n                        var file = m[1], lineno = m[2], charno = m[3] || 0;\n                        if (file && this.isSameDomain(file) && lineno) {\n                            var functionName = this.guessAnonymousFunction(file, lineno, charno);\n                            stack[i] = frame.replace('{anonymous}', functionName);\n                        }\n                    }\n                }\n            }\n            return stack;\n        },\n\n        guessAnonymousFunction: function(url, lineNo, charNo) {\n            var ret;\n            try {\n                ret = this.findFunctionName(this.getSource(url), lineNo);\n            } catch (e) {\n                ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();\n            }\n            return ret;\n        },\n\n        findFunctionName: function(source, lineNo) {\n            // FIXME findFunctionName fails for compressed source\n            // (more than one function on the same line)\n            // function {name}({args}) m[1]=name m[2]=args\n            var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\n            // {name} = function ({args}) TODO args capture\n            // /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*function(?:[^(]*)/\n            var reFunctionExpression = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/;\n            // {name} = eval()\n            var reFunctionEvaluation = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\n            // Walk backwards in the source lines until we find\n            // the line which matches one of the patterns above\n            var code = \"\", line, maxLines = Math.min(lineNo, 20), m, commentPos;\n            for (var i = 0; i < maxLines; ++i) {\n                // lineNo is 1-based, source[] is 0-based\n                line = source[lineNo - i - 1];\n                commentPos = line.indexOf('//');\n                if (commentPos >= 0) {\n                    line = line.substr(0, commentPos);\n                }\n                // TODO check other types of comments? Commented code may lead to false positive\n                if (line) {\n                    code = line + code;\n                    m = reFunctionExpression.exec(code);\n                    if (m && m[1]) {\n                        return m[1];\n                    }\n                    m = reFunctionDeclaration.exec(code);\n                    if (m && m[1]) {\n                        //return m[1] + \"(\" + (m[2] || \"\") + \")\";\n                        return m[1];\n                    }\n                    m = reFunctionEvaluation.exec(code);\n                    if (m && m[1]) {\n                        return m[1];\n                    }\n                }\n            }\n            return '(?)';\n        }\n    };\n\n    return printStackTrace;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stacktrace-js/stacktrace.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}